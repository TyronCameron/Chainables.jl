var documenterSearchIndex = {"docs":
[{"location":"api/#Chainables-API","page":"API","title":"Chainables API","text":"","category":"section"},{"location":"api/#Chainables","page":"API","title":"Chainables","text":"Chainables.jl is a library for working better with Chain.jl \n\n\n\n\n\n","category":"module"},{"location":"api/#Module-Index","page":"API","title":"Module Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [Chainables]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Chainables.Partial","page":"API","title":"Chainables.Partial","text":"Partial\n\nA lightweight struct to hold a function and its args, for the purposes of partial application.  \n\n\n\n\n\n","category":"type"},{"location":"api/#Chainables.Placeholder","page":"API","title":"Chainables.Placeholder","text":"Placeholder\n\nA simple type to represent a placeholder in a partially applied function. \n\n\n\n\n\n","category":"type"},{"location":"api/#Chainables.Unzip","page":"API","title":"Chainables.Unzip","text":"Unzip\n\nA lazy type to undo zipping. Created when calling unzip(zipped_iter)\n\n\n\n\n\n","category":"type"},{"location":"api/#Chainables.apply-Tuple{Any, Vararg{Any}}","page":"API","title":"Chainables.apply","text":"apply(f, args...; kwargs...)\n\nSimply apply f with the args and kwargs given. \n\n\n\n\n\n","category":"method"},{"location":"api/#Chainables.pack-Tuple","page":"API","title":"Chainables.pack","text":"pack(args...)\n\nSimply return the args in a tuple. \n\n\n\n\n\n","category":"method"},{"location":"api/#Chainables.partial-Tuple{Partial, Vararg{Any}}","page":"API","title":"Chainables.partial","text":"partial(f, args...; kwargs...)\n\nCreate a Partial (a partially applied function). For more convenience, see @partial or @∂. \n\nExample:\n\nf(a,b) = 2*a + b\nf_partial = partial(f, 3) # put 3 in place of a \n@assert f_partial(1) == f(3, 1)\n\nThis can handle varargs and kwargs: \n\nfoo(args...; kwargs...) = sum(args) + length(kwargs) \nfoo_partial = @∂ foo(10, 10; a = 5)\nfoo_partial(20; b = 7) == foo(10,10,20; a = 5, b = 7) == 42\n\nYou can choose where the positional arguments get curried to with use of @x.\n\nfoo_partial_2 = @∂ foo(10, @x; a = 5)\nfoo_partial_2(30; b = 7) == foo(10,30; a = 5, b = 7) == 42\n\nIf you have not fully exhausted the list of unknown placeholders, and you call a Partial, you will get back a Partial.  As such:\n\nfoo_partial_3 = @∂ foo(1,@x,@x,@x)\nfoo_partial_4 = foo_partial_3(10)\nfinal_answer = foo_partial_4(30)(1)\n@assert final_answer == foo(1,10,30,1) == 42\n\nYou can chain partials together as follows: \n\nbar(args...) = sum(args)\n\nb1 = @∂ bar(6,@x,2,@x,@x,12)\nb2 = @∂ b1(5,10) \nb3 = @∂ b1(@x,10,7)\n\n@assert @all [\n    b1(5,10,7)\n    b2(7)\n    b3(5)\n] @∂ ==(42) \n\n\n\n\n\n","category":"method"},{"location":"api/#Chainables.rev-Tuple{Function}","page":"API","title":"Chainables.rev","text":"rev(f::Function)\n\nRearrange the inputs to f such that the original first arg is now the last one.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chainables.unpack-Tuple{Any}","page":"API","title":"Chainables.unpack","text":"unpack(f::Function)\n\nReturn a valid form of f that can destructure its args. Also see @unpack.  Without this function you may find yourself working with tuples as a single argument to a function.\n\nFor instance, the usage of t[1] and t[2] in the following is untasty. \n\n@chain 1:10 begin\n    zip(20:30)\n    @map t -> t[1] + t[2]\nend\n\nWith this function, you write something equally untasty: \n\n@chain 1:10 begin\n    zip(20:30)\n    @map unpack((a, b) -> a + b)\nend\n\nSee @unpack for something better.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chainables.unzip-Tuple{Any}","page":"API","title":"Chainables.unzip","text":"unzip(zipped_iter)\n\nLazily unzip a zipped structure. Useful when you need to zip structures together, compute results, and then get back your original iterators. \n\n@chain [1,2,3] begin \n    zip([4,5,6]) \n    collect\n    @filter @unpack (x,y) -> x + y <= 7\n    unzip \n    @. collect \nend \n\n\n\n\n\n","category":"method"},{"location":"api/#Chainables.vectorise-Tuple{Any}","page":"API","title":"Chainables.vectorise","text":"vectorise(f::Function)\n\nReturn the vectorised form of the function. \n\n\n\n\n\n","category":"method"},{"location":"api/#Chainables.with-Tuple{Function, Vararg{Any}}","page":"API","title":"Chainables.with","text":"with(f::Function, args...; kwargs...)\n\nCurry out the first variable from function f. This is useful if you wanted do blocks in chain statements. For instance:\n\n@chain 12 begin \n    @apply with(1) do x,y\n        x^2 + y \n    end \nend \n# == 12^2 + 1 == 145\n\n\n\n\n\n","category":"method"},{"location":"api/#Chainables.λ-Tuple{Partial}","page":"API","title":"Chainables.λ","text":"λ(partial::Partial)\n\nConvert the partial back into a function. \n\n\n\n\n\n","category":"method"},{"location":"api/#Chainables.@apply-Tuple","page":"API","title":"Chainables.@apply","text":"@apply(x, f)\n\nApply f to x. Useful when chaining. For example, imagine we want the first letter of the second word in the following sentence: \n\nx = @chain \"Hello Fine Ladies\" begin \n    split.(\" \")\n    @apply x -> x[2][1]\nend \n@assert x == 'F'\n\n\n\n\n\n","category":"macro"},{"location":"api/#Chainables.@pack-Tuple","page":"API","title":"Chainables.@pack","text":"@pack(args...)\n\nSimply returns the args in a tuple.\n\n\n\n\n\n","category":"macro"},{"location":"api/#Chainables.@partial-Tuple{Any}","page":"API","title":"Chainables.@partial","text":"@partial(expr)\n\nA macro form of the partial function. See that function for further documentation. \n\nfoo(varargs...) = sum(varargs)\np1 = @partial foo(1)\np2 = @∂ foo(1)\np3 = partial(foo, 1)\n@assert p1 == p2 == p3 \n\n\n\n\n\n","category":"macro"},{"location":"api/#Chainables.@rev-Tuple{Any, Any}","page":"API","title":"Chainables.@rev","text":"@rev(arg, expr)\n\nRearrange arg to go into the expr. Useful for doing this kind of thing: \n\n@chain 1:100 begin \n    @rev reduce(+)\nend \n\n\n\n\n\n","category":"macro"},{"location":"api/#Chainables.@unpack-Tuple","page":"API","title":"Chainables.@unpack","text":"@unpack(f::Function)\n\nThe macro equivalent of unpack. \n\nEnables unpacking of tuples. For instance, the usage of t[1] and t[2] in the following is untasty. \n\n@chain 1:10 begin\n    zip(20:30)\n    @map t -> t[1] + t[2]\nend\n\nWith this macro, you write something tasty: \n\n@chain 1:10 begin\n    zip(20:30)\n    @map @unpack (a, b) -> a + b \nend\n\nThis uses splatting under the hood so it's not too efficient for a high number of args. For a small number of args, this is good. \n\n\n\n\n\n","category":"macro"},{"location":"api/#Chainables.@vec-Tuple{Any}","page":"API","title":"Chainables.@vec","text":"@vec(f::Function)\n\nReturn the vectorised form of the function. Useful for ensuring vectorisation when using other utilities from the Chainables.jl package. For example:  \n\n@chain 1:3 begin \n    zip(4:6)\n    @apply @vec @unpack (a, b) -> a * b^2\nend \n\n\n\n\n\n","category":"macro"},{"location":"api/#Chainables.@x-Tuple{}","page":"API","title":"Chainables.@x","text":"@x\n\nA quick macro to create a placeholder variable for partial application (currying) purposes. \n\n@x creates a Placeholder, and this is recognised by:\n\npartial (the function) such as partial(foo, arg1, @x, arg2)\n@partial (the macro) such as @partial foo(arg1, @x, arg2)\n@∂ such as @∂ foo(arg1, @x, arg2)\n\n\n\n\n\n","category":"macro"},{"location":"api/#Chainables.@∂","page":"API","title":"Chainables.@∂","text":"@∂(expr)\n\nSee @partial or partial. \n\n\n\n\n\n","category":"macro"},{"location":"#Chainables.jl","page":"Index","title":"Chainables.jl","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"Chainables is a package to help you @chain (from Chain.jl) things together better. This package is inspired by the awesome work done by Chain.jl as well as DataFramesMeta.jl. I love the concept of chaining functions in the order of execution, and I think it makes code much easier to reason about. ","category":"page"},{"location":"","page":"Index","title":"Index","text":"This packages adds a few utilities to that way of thinking. ","category":"page"},{"location":"","page":"Index","title":"Index","text":"You can install this package by pressing ] in the Julia REPL and writing add <github repo>. ","category":"page"},{"location":"","page":"Index","title":"Index","text":"This package reexports @chain and provides:","category":"page"},{"location":"","page":"Index","title":"Index","text":"A slightly more pleasant way to write anonymous functions (lambdas) during chaining. It does this mainly with @apply, with. \nPacking and unpacking of arguments, namely with @pack, @unpack. The latter simply packs varargs into a tuple, and the latter unpacks a tuple into varargs in a function definition. Useful if you want to splat a tuple into a chained function. \nReverse-argument macro-versions of common iterator functions. While the base Julia versions accept a function as the first argument, these accept the iterator as the first argument, allowing simpler chaining. @filteriter, @map, @filter, @reduce, @foldl, @foldr, @accumulate. It also provides a macro @rev to reverse your own functions and macros on-the-fly.\nReverse-argument aggregation functions, such as @count, @sum, @prod, @minimum, @maximum, @any, @all, @extrema, @argmin, @argmax, @findfirst, @findlast\nReverse-argument conversions and parsing, just in case you needed them: @convert, @parse,\nA handy unzip tool, allowing you to create a lazy iterator over a zipped iterator! Useful if you wanted to zip, do some transformations, and get back the unzipped iterators. \nvectorise, @vec as a simple was of wrapping a function to be in a vectorised form. \nNice partial application (currying) of functions, with @x, @∂, partial, @partial, Placeholder","category":"page"},{"location":"#Anonymous-function-chaining","page":"Index","title":"Anonymous function chaining","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"Old way: ","category":"page"},{"location":"","page":"Index","title":"Index","text":"@chain 5 begin\t\n\t(x -> x^2 + 10)()\nend ","category":"page"},{"location":"","page":"Index","title":"Index","text":"New way: ","category":"page"},{"location":"","page":"Index","title":"Index","text":"using Chainables\n\n# for small anon functions \n@chain 5 begin \n\t@apply x -> x^2 + 10\nend\n\n# for big ugly anon functions\n@chain 5 begin \n\t@apply with() do x \n\t\tx^2 + 10\n\tend \nend","category":"page"},{"location":"#Packing-and-unpacking","page":"Index","title":"Packing and unpacking","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"Imagine we wanted to filter one array based on another. There are lots of ways to do this, but one of them is to use zipping, filtering, and then mapping back to one of the zipped iterators. ","category":"page"},{"location":"","page":"Index","title":"Index","text":"@chain 1:10 begin\n    zip(21:30)\n\tcollect\n    filter(t -> t[2] <= 25, _)\n    map(t -> t[1], _)\nend","category":"page"},{"location":"","page":"Index","title":"Index","text":"With this package, you can instead write: ","category":"page"},{"location":"","page":"Index","title":"Index","text":"@chain 1:10 begin\n    zip(21:30)\n\tcollect\n    @filter @unpack (a, b) -> b <= 25\n\t@map @unpack (a, b) -> a\nend","category":"page"},{"location":"#Reverse-argument-macros","page":"Index","title":"Reverse-argument macros","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"You can reverse any function or macro like this: ","category":"page"},{"location":"","page":"Index","title":"Index","text":"@chain 1:100 begin\n\t@rev reduce(+)\nend \n\n@chain 1:100 begin\n\ttempval = @rev reduce(+)\nend \n\n@chain 1:100 begin\n\t@rev @info \"abc\"\nend \n\n@chain 1:100 begin\n\ttempval = @rev @pack \"abc\"\nend ","category":"page"},{"location":"","page":"Index","title":"Index","text":"But I did it in a very nice way for the common ones already. ","category":"page"},{"location":"","page":"Index","title":"Index","text":"Old way:","category":"page"},{"location":"","page":"Index","title":"Index","text":"@chain 1:100 begin\n\tmap(x -> x^2, _)\n\tfilter(x -> x < 80, _)\n\tcount(x -> x % 2 == 0, _)\nend ","category":"page"},{"location":"","page":"Index","title":"Index","text":"New way:","category":"page"},{"location":"","page":"Index","title":"Index","text":"@chain 1:100 begin\n\t@map x -> x^2\n\t@filter x -> x < 80\n\t@count x -> x % 2 == 0\nend ","category":"page"},{"location":"","page":"Index","title":"Index","text":"Naturally this comes with all the bells and whistles, such as kwargs. For example, let's say we wanted to figure out the maximum strength of each level, when not ceding, in the Hierarchy in the book \"The Will of the Many\". We might wish for an initialising variable. ","category":"page"},{"location":"","page":"Index","title":"Index","text":"@chain 8:-1:1 begin\n\t@accumulate init = 0 with() do child_strength, level\n\t\tchild_strength * (level + 1) / 2 + 1\n\tend \nend ","category":"page"},{"location":"","page":"Index","title":"Index","text":"If the with() is confusion, just remember that with() do args expr end is the same as (args) -> expr, but it gives you access to a nice big block to write more complicated code. ","category":"page"},{"location":"","page":"Index","title":"Index","text":"It doesn't matter where you put the kwargs when calling these macros. Anything of the form a = b will be treated as a kwarg. ","category":"page"},{"location":"#Partial-application","page":"Index","title":"Partial application","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"This is broader than chaining, but I think it's related, because it relates to composition, and completes out the @pack, @unpack and @chain ideas. ","category":"page"},{"location":"","page":"Index","title":"Index","text":"The idea is just to simplify creating new lambas. ","category":"page"},{"location":"","page":"Index","title":"Index","text":"function foo(a,b,c; kw = 13)\n\ta + b + c + kw\nend ","category":"page"},{"location":"","page":"Index","title":"Index","text":"Now you might know the values of b and c, but want to vary a. Therefore, you would create a new function:","category":"page"},{"location":"","page":"Index","title":"Index","text":"foo_lambda = a -> foo(a, 11, 12; kw = 14)","category":"page"},{"location":"","page":"Index","title":"Index","text":"Then you can call it later and have a happy life:","category":"page"},{"location":"","page":"Index","title":"Index","text":"foo_lambda.(1:10) # a is varying, the other vars are fixed","category":"page"},{"location":"","page":"Index","title":"Index","text":"Alternatively, you can use partial application. Now this package provides two ways to do this. The first is simply a nice way to generate these lambda functions. The second way creates a wrapper, which is good if you want repeated partial application, which is admittedly a rare circumstance. ","category":"page"},{"location":"","page":"Index","title":"Index","text":"The first way is the simpler (and faster) way as it just takes in a function and returns a function: ","category":"page"},{"location":"","page":"Index","title":"Index","text":"foo_partial = partial(foo, @x, 11, 12; kw = 14) # @x denotes the \"varying\" argument(s)","category":"page"},{"location":"","page":"Index","title":"Index","text":"Or in shorthand:","category":"page"},{"location":"","page":"Index","title":"Index","text":"foo_partial = @∂ foo(@x, 11, 12; kw = 14)\nfoo_partial(10)\n@assert foo_partial(10) == foo_lambda(10)","category":"page"},{"location":"","page":"Index","title":"Index","text":"You can also use @partial instead of @∂ in case you like having the full word around. ","category":"page"},{"location":"","page":"Index","title":"Index","text":"This is pretty stylish in and of itself, but it can have an application when chaining too:","category":"page"},{"location":"","page":"Index","title":"Index","text":"baz(x) = (x^2, x^3) # a function with two outputs\n\nfirst = @chain 10 begin\n\tbaz # returns 2 values\n\t@unpack @∂ foo(@x, 12, @x; kw = 20) # choose exactly where those two args go into the subsequent function\nend \n\n# Now let's check that we're still getting the right result\na, b = baz(10)\nsecond = foo(a, 12, b; kw = 20)\n\n@assert first == second ","category":"page"},{"location":"","page":"Index","title":"Index","text":"Finally, there is another way to do partial application. We create a Partial type which can be called like any regular function. ","category":"page"},{"location":"","page":"Index","title":"Index","text":"foo_Partial = Partial(foo)\nfoo_Partial(1; kw = 20) # automatically figures out where the placeholders are needed\nfoo_Partial(1)(2) # still a Partial\nfoo_Partial(1)(2)(3) # still a Partial\nfoo_Partial(1)(2)(3)() # the last empty value returns a value\n\n# alternatives\n@assert foo_Partial(1, @x)(2)(3)() == foo(1, 2, 3) # exhause items, can use placeholders\n@assert λ(foo_Partial(1)(2))(3) == foo(1, 2, 3) # convert back to regular lambda\n@assert apply(foo_Partial(1)(2), 3; kw = 10) == foo(1,2,3; kw = 10) # apply works on this too! ","category":"page"},{"location":"","page":"Index","title":"Index","text":"This Partial type causes more overhead than using the plain functions. However, it provides additional convenience for repeated calls, printing, and arg checking before you actually call the function. ","category":"page"}]
}
